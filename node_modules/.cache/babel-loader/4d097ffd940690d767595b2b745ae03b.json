{"ast":null,"code":"module.exports = initials; // extend public API\n\ninitials.addTo = addInitialsTo;\ninitials.parse = parse;\ninitials.find = initials; // defaults\n\nvar defaultLength = 2; // there is no support for look-behinds in JS, and the \\b selector\n// doesn't work with diacritics. So we maintain a blacklist of\n// \"non letters\", that we use later to build our regex.\n\nvar nonLetters = ' -\\\\/:-@\\\\[-`\\\\{-\\\\~'; // regex patterns\n\nvar uppercaseLettersOnlyPattern = /^[A-Z]+$/;\nvar initialsInNamePattern = /\\(([^\\)]+)\\)/;\nvar nameIsEmailPattern = /^[^\\s]+@[^\\s]+$/;\nvar findDomainInEmailPattern = /@[^\\s]+/;\nvar findEmailPattern = /[\\w\\._-]+@[\\w\\.-]+[\\w]/g; // match everything that is a \"non letter\" (see above)\n// followed by all but a \"non letter\".\n// Expl: \"Jörg Jäger-Franke\" => [\"J\", \" J\", \"-F\"]\n\nvar findFirstLettersOfWordsPattern = new RegExp('(^|[' + nonLetters + '])[^' + nonLetters + ']', 'g');\nvar findAllNonCharactersPattern = new RegExp('[' + nonLetters + ']', 'g'); // PUBLIC API METHODS\n//\n// initials allows to be used with either a string or an array of strings\n//\n\nfunction initials(nameOrNames, options) {\n  if (!nameOrNames) return '';\n  if (typeof nameOrNames === 'string') return initialsForSingleName(nameOrNames, normalize(options));\n  return initialsForMultipleNames(nameOrNames, normalize(options));\n} //\n// finds initials in a name and adds them to the right side\n//\n\n\nfunction addInitialsTo(nameOrNames, options) {\n  if (!nameOrNames) return '';\n  if (typeof nameOrNames === 'string') return addInitialsToSingleName(nameOrNames, normalize(options));\n  return addInitialsToMultipleNames(nameOrNames, normalize(options));\n} //\n// extract name, initials, email\n//\n\n\nfunction parse(nameOrNames, options) {\n  if (!nameOrNames) return {};\n  if (typeof nameOrNames === 'string') return parseSingleName(nameOrNames, normalize(options));\n  return parseMultipleNames(nameOrNames, normalize(options));\n} // HELPER METHODS\n//\n// Find initials in a single given name string\n//\n\n\nfunction initialsForSingleName(name, options) {\n  var matches;\n  var result;\n  var initials;\n  var length = options.length || 2;\n  initials = findPreferredInitials(name, options);\n  if (initials) return initials;\n  name = cleanupName(name);\n  if (!name) return ''; // there is no support for look-behinds in JS, and the \\b selector\n  // doesn't work with diacritics. So we match everything that is a\n  // \"non character\" followed by all but a \"non character\". To fix\n  // that, we map the results to its last character.\n  // Expl: \"Jörg Jäger\" => [\"J\", \" J\"] => [\"J\", \"J\"]\n\n  matches = name.match(findFirstLettersOfWordsPattern).map(function (match) {\n    return match[match.length - 1];\n  });\n\n  if (matches.length < 2) {\n    if (name.length > length) {\n      return name.substr(0, length);\n    } else {\n      return name;\n    }\n  } else {\n    result = matches.join('');\n  }\n\n  if (result.length >= length) {\n    return result;\n  } // This is where it gets complicated.\n  // Let's say we're in initials('John Doe', 3), so up to here\n  // we have `result === 'JD'`, but what we want is `result === `JDo`.\n  // First, we calculate all remaining options that we have\n\n\n  var possibleInitials = getPossibleInitialsForName(name);\n  var option; // then we return the first option that has the required length\n\n  for (var i = 0; i < possibleInitials.length; i++) {\n    if (possibleInitials[i].length >= length) return possibleInitials[i];\n  }\n\n  ; // if that didn't work, we return the last possible option\n\n  return option;\n} //\n//\n//\n\n\nfunction initialsForMultipleNames(names, options) {\n  var optionsForNames = [];\n  var optionsCountForNames;\n  var map = {};\n  var duplicatesMap = {};\n  var initialsForNamesMap = {};\n  var initials;\n  var possibleInitials;\n  var length = options.length || 2; // get all possible initials for all names for given length\n\n  names.forEach(function (name) {\n    // normalize\n    if (!name) name = ''; // known name? Gets same initials, stop here\n\n    if (initialsForNamesMap[name]) return; // too short to extract initials from? Use name as initials.\n\n    if (name.length < length) {\n      initialsForNamesMap[name] = [name];\n      return;\n    } // preferred initials like (JD)? Use these\n\n\n    initials = findPreferredInitials(name, options);\n\n    if (initials) {\n      map[initials] = 1;\n      initialsForNamesMap[name] = [initials];\n      return;\n    } // return all possible initials for given length\n\n\n    possibleInitials = getPossibleInitialsForName(name).filter(function (initials) {\n      if (initials.length !== length) return false;\n      if (map[initials]) duplicatesMap[initials] = 1;\n      map[initials] = 1;\n      return true;\n    });\n    initialsForNamesMap[name] = possibleInitials;\n  }); // remove duplicates\n\n  var keys = [];\n\n  for (var k in initialsForNamesMap) {\n    keys.unshift(k);\n  }\n\n  for (var c = keys.length, n = 0; n < c; n++) {\n    possibleInitials = initialsForNamesMap[keys[n]];\n    optionsForNames.push(possibleInitials);\n\n    for (var i = 0; i < possibleInitials.length; i++) {\n      if (duplicatesMap[possibleInitials[i]] > 0) {\n        duplicatesMap[possibleInitials[i]]--;\n        possibleInitials.splice(i, 1);\n      }\n    }\n  } // make sure we still have options for every name\n\n\n  optionsCountForNames = optionsForNames.map(function (options) {\n    return options.length;\n  }); // if names were empty, optionsCountForNames is empty. In that case stop here\n\n  if (optionsCountForNames.length === 0) return names;\n\n  if (Math.min.apply(null, optionsCountForNames) === 0) {\n    options.length++;\n    return initialsForMultipleNames(names, options);\n  } // if we do, return the first option for each\n\n\n  return names.map(function (name) {\n    return initialsForNamesMap[name][0];\n  });\n} //\n//\n//\n\n\nfunction addInitialsToSingleName(name, options) {\n  var parts = parseSingleName(name, options);\n  return format(parts);\n} //\n//\n//\n\n\nfunction addInitialsToMultipleNames(names, options) {\n  return parseMultipleNames(names, options).map(format);\n} //\n//\n//\n\n\nfunction parseSingleName(name, options) {\n  var initials;\n  var email;\n  var matches;\n  var parts = {};\n  if (!name) return {}; // are initials part of the name?\n\n  initials = findPreferredInitials(name, options);\n\n  if (initials) {\n    // if yes, remove it from name\n    name = name.replace(uppercaseLettersOnlyPattern, '');\n    name = name.replace(initialsInNamePattern, '');\n  } // use preferred initials if passed\n\n\n  if (options.initials) initials = options.initials; // if no initials found yet, extract initials from name\n\n  if (!initials) initials = initialsForSingleName(name, options); // is there an email in the name?\n\n  matches = name.match(findEmailPattern);\n  if (matches != null) email = matches.pop();\n\n  if (email) {\n    // if yes, remove it from name\n    name = name.replace(email, ''); // if the email and the name are the same, initials can not be rendered\n    // the initials method uses email for rendering just when the name is false\n    // see https://github.com/gr2m/initials/issues/7 for more details\n\n    if (name.trim() === '<' + email + '>') {\n      // set the name to undefined\n      name = ''; // fire up the initials again with the email\n\n      if (!initials) {\n        initials = initialsForSingleName(email, options);\n      }\n    }\n  } // clean up the rest\n\n\n  name = name.replace(findAllNonCharactersPattern, ' ').trim(); // do only return what's present\n\n  if (name) parts.name = name;\n  if (initials) parts.initials = initials;\n  if (email) parts.email = email;\n  return parts;\n} //\n//\n//\n\n\nfunction parseMultipleNames(names, options) {\n  var initialsArray = initialsForMultipleNames(names, options);\n  return names.map(function (name, i) {\n    options.existing[name] = initialsArray[i];\n    return parseSingleName(name, options);\n  });\n} //\n//\n//\n\n\nfunction format(parts) {\n  // neither name nor email: return initials\n  if (!parts.name && !parts.email) return parts.initials; // no email: return name with initials\n\n  if (!parts.email) return parts.name + ' (' + parts.initials + ')'; // no name: return email with initials\n\n  if (!parts.name) return parts.email + ' (' + parts.initials + ')'; // return name with initials & name\n\n  return parts.name + ' (' + parts.initials + ') <' + parts.email + '>';\n} //\n//\n//\n\n\nfunction cleanupName(name) {\n  // in case the name is an email address, remove the @xx.yy part\n  // otherwise remove an eventual email address from name\n  if (nameIsEmailPattern.test(name)) {\n    name = name.replace(findDomainInEmailPattern, '');\n  } else {\n    name = name.replace(findEmailPattern, '');\n  } // replace all non characters with ' ' & trim\n\n\n  name = name.replace(findAllNonCharactersPattern, ' ').trim();\n  return name;\n} //\n//\n//\n\n\nfunction findPreferredInitials(name, options) {\n  var matches; // if preferred initials passed for current name\n\n  if (options.existing[name]) return options.existing[name]; // if the name contains only upcase letters, let's take it as the initials as well\n\n  if (uppercaseLettersOnlyPattern.test(name)) {\n    return name;\n  } // are the initials part of the given name, e.g. »Eddie Murphie (em)«?\n\n\n  matches = name.match(initialsInNamePattern); // if yes, return them\n\n  if (matches != null) {\n    return matches.pop();\n  }\n} //\n// e.g. for John Doe:\n// - JDo\n// - JDoe\n// - JoDoe\n// - JohDoe\n// - JohnDoe\n//\n\n\nvar cache = {};\n\nfunction getPossibleInitialsForName(name) {\n  var parts;\n  var partsPossibilities;\n  var options = [];\n  name = cleanupName(name);\n\n  if (cache[name]) {\n    return cache[name].slice(0); // return copy\n  } // split names into parts\n  // 'John Doe' => ['Doe', 'John']\n\n\n  parts = name.split(' '); // map parts to all its possible initials\n  // 'John' => ['J', 'Jo', 'Joh', 'John']\n\n  partsPossibilities = parts.map(getPossibleInitialsForWord);\n  options = combineAll(partsPossibilities); // sort options, shortest first\n\n  options = options.sort(function (a, b) {\n    return a.length - b.length || options.indexOf(a) - options.indexOf(b);\n  }); // cache for future\n\n  cache[name] = options; // return options\n\n  return options.slice(0);\n} //\n//\n//\n\n\nfunction combineAll(array) {\n  var current = array.shift();\n  var temp;\n  var results;\n\n  if (array.length > 0) {\n    results = [];\n    temp = combineAll(array);\n    current.forEach(function (value1) {\n      temp.forEach(function (value2) {\n        results.push(value1 + value2);\n      });\n    });\n    return results;\n  } else {\n    return current;\n  }\n} //\n//\n//\n\n\nfunction getPossibleInitialsForWord(word) {\n  var options = [];\n\n  while (word.length) {\n    options.unshift(word);\n    word = word.substr(0, word.length - 1);\n  }\n\n  return options;\n} //\n// make sure that options is always an object, and that\n// * options.length is a number and >= defaultLength\n// * existing is set and an object\n//\n\n\nfunction normalize(options) {\n  if (!options) options = {\n    length: defaultLength\n  };\n  if (typeof options === 'number') options = {\n    length: options\n  };\n  options.length = Math.max(options.length || 0, defaultLength);\n  options.existing = options.existing || {};\n  return options;\n}","map":null,"metadata":{},"sourceType":"script"}